<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Postgres Performance Tuning Manual: Query Plans | Kishan&#39;s World</title>
<meta name="keywords" content="postgres, query-plans">
<meta name="description" content="Is Postgres slowing down on you? Here&#39;s how to identify areas of improvement using query plans">
<meta name="author" content="Kishan Sharma">
<link rel="canonical" href="http://kishansharma.in/posts/postgres-performance-tuning-manualquery-plans/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5e075fac125b9f37cb03d7e9b44b819cc97ad60447f78258d02b5023d6ecec40.css" integrity="sha256-XgdfrBJbnzfLA9fptEuBnMl61gRH94JY0CtQI9bs7EA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://kishansharma.in/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://kishansharma.in/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://kishansharma.in/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://kishansharma.in/apple-touch-icon.png">
<link rel="mask-icon" href="http://kishansharma.in/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Postgres Performance Tuning Manual: Query Plans" />
<meta property="og:description" content="Is Postgres slowing down on you? Here&#39;s how to identify areas of improvement using query plans" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://kishansharma.in/posts/postgres-performance-tuning-manualquery-plans/" />
<meta property="og:image" content="http://kishansharma.in/img/elephant-postgres.jpg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-26T00:11:32+05:30" />
<meta property="article:modified_time" content="2023-03-26T00:11:32+05:30" />
<meta property="og:see_also" content="http://kishansharma.in/posts/postgres-performance-tuning-manualindexes/" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://kishansharma.in/img/elephant-postgres.jpg" />
<meta name="twitter:title" content="Postgres Performance Tuning Manual: Query Plans"/>
<meta name="twitter:description" content="Is Postgres slowing down on you? Here&#39;s how to identify areas of improvement using query plans"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://kishansharma.in/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Postgres Performance Tuning Manual: Query Plans",
      "item": "http://kishansharma.in/posts/postgres-performance-tuning-manualquery-plans/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Postgres Performance Tuning Manual: Query Plans",
  "name": "Postgres Performance Tuning Manual: Query Plans",
  "description": "Is Postgres slowing down on you? Here's how to identify areas of improvement using query plans",
  "keywords": [
    "postgres", "query-plans"
  ],
  "articleBody": "Postgres is one of the most widely used open source databases in the world. At GOJEK, a lot of our products depend on Postgres as well. A lot of major companies use Postgres as their main database however when you’re building and operating at scale, the volume of data passing through the pipelines can slow down the most efficient systems.\nTo optimise things in order to enhace performace, we can target the brain of the database whhich is optimizer. Optimizer interprets queries and determines the fastest method of execution. A single query optimization technique can increase database performance drastically.\nThis post outlines how to analyse Postgres performance using tools such as EXPLAIN and ANALYZE (which Postgres provides).\nMeet EXPLAIN \u0026 ANALYZE EXPLAIN gives an exact breakdown of a query. The execution plan is based on the statistics about the table, and it identifies the most efficient path to the data. This takes different database paradigms (such as indexes) into consideration. EXPLAIN only guesses a plan that it thinks it will execute. This is where ANALYZE comes into the picture. ANALYZE basically runs a query to find the processing time to execute a query.\nTo quickly summarise, EXPLAIN and ANALYZE commands help improve database performance in Postgres by:\na. Displaying the execution plan that the PostgreSQL planner generates for the supplied statement.\nb. Actually running the command to show the run time.\nFinding the framework Let’s consider we have a table named schemes.\nEXPLAIN SELECT * FROM schemes; QUERY PLAN | Seq Scan on schemes (cost=0.00..64 rows=328 width=479)\nSELECT * FROM pg_class where relname = 'schemes'; pg_class has the metadata about the tables.\nCost in the query plan is calculated using the following formula\nCOST = (disk read pages x seq_page_cost) + (rows scanned x cpu_tuple_cost).\nDisk read pages and rows scanned are the properties of pg_class. Seq page cost is the estimated cost of disk read fetch. Cpu tuple cost is the estimated cost of processing each row. eg., COST (54 x 1.0) + (1000 x .01) = 64 Let’s see how the query plan changes when we apply filters in the select statement.\nEXPLAIN SELECT * FROM schemes WHERE status = 'active'; QUERY PLAN | Seq Scan on schemes (cost=0.00..66.50 rows=960 width=384) Filter: ((status)::text = ‘active’::text)\nThe estimated cost here is higher than the previous query, this is because Postgres is performing a seq scan over 1000 rows first and then filtering out the rows based on the WHERE clause.\nPlanner cost constants The cost variables described in this section are measured on an arbitrary scale. Only their relative values matter, hence scaling them all up or down by the same factor will result in no change in the planner’s choices. By default, these cost variables are based on the cost of sequential page fetches; that is, seq_page_cost is conventionally set to 1.0 and the other cost variables are set with reference to that. But you can use a different scale if you prefer, such as actual execution times in milliseconds on a particular machine.\nUnfortunately, there is no well-defined method for determining ideal values for the cost variables. They are best treated as averages over the entire mix of queries that a particular installation will receive. This means that changing them on the basis of just a few experiments is very risky. Refer planner cost constants].\nEXPLAIN SELECT schemes.rules FROM scheme_rules JOIN schemes ON (scheme_rules.scheme_id = schemes.id ) where scheme_name = 'weekend_scheme'; The query planner sometimes decides to use a two-step plan. The reason for using two-plan node is the first plan sorts the row locations identified by the index into physical order before reading them, and the other plan actually fetches those rows from the table.\nDown to the nuts and bolts The first plan which does the sorting is called Bitmap scan.\nMost common occurring matches are scanned using the seq scan and the least common matches are scanned using index scan, anything in between is scanned using bitmap heap scan followed by an index scan. One of the reasons for this is that the random I/O is very slow as compared to sequential I/O. This is all driven by analysing statistics.\nBitmap heap scan A bitmap heap scan is like a seq scan - the difference being, rather than visiting every disk page, it scans ANDs and ORs of the applicable index together and only visits the disk pages it needs to visit. This is different from index scan where the index is visited row by row in order, which results in disk pages being visited multiple times. A bitmap scan will sequentially open a short list of disk pages and grab every applicable row in each one.\nSequential scan vs index scan There are cases where a sequential scan is faster than an index scan. When reading data from a disk, a sequential method is usually faster than reading in random order. This is because an index scan requires several I/O for each row which includes looking up a row in the index, and based on that, looking up and retrieving the row from memory(heap). On the other hand, a sequential scan requires a single I/O operation to retrieve more than one block containing multiple rows.\nQuery plan on JOINS The optimizer needs to pick the correct join algorithm when there are multiple tables to be joined in the select statement. Postgres uses three different kinds of join algorithms based on the type of join we are using.\nLet’s dive in\nNested Loop: Here the planner can use either a sequential scan or index scan for each of the elements in the first table. The planner uses a sequential scan when the second table is small. The basic logic of choosing between a sequential scan and index scan applies here too. Hash Join: In this algorithm, the planner creates a hash table of the smaller table on the join key. The larger table is then scanned, searching the hash table for the rows which meet the join condition. This requires a lot of memory to store the hash table in the first place. Merge Join: This is similar to merge sort algorithm. Here the planner sorts both the tables to be joined on the join attribute. The tables are then scanned in parallel to find the matching values.\nFurther reading on how we can use Explain/Analyze with join statements here\nPostgres performance tuning is a complicated task. The complexity comes in identifying the appropriate ’tunable’ from the many tools that Postgres provides. As you might have now guessed, there is no silver bullet to solving performance issues in Postgres - it’s the use case that dictates the tuning requirements. 😅\nHope this helped. Keep following the blog for more updates! 🙂\n",
  "wordCount" : "1127",
  "inLanguage": "en",
  "image":"http://kishansharma.in/img/elephant-postgres.jpg","datePublished": "2023-03-26T00:11:32+05:30",
  "dateModified": "2023-03-26T00:11:32+05:30",
  "author":[{
    "@type": "Person",
    "name": "Kishan Sharma"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://kishansharma.in/posts/postgres-performance-tuning-manualquery-plans/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kishan's World",
    "logo": {
      "@type": "ImageObject",
      "url": "http://kishansharma.in/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://kishansharma.in/" accesskey="h" title="Kishan Sharma (Alt + H)">Kishan Sharma</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://kishansharma.in/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://kishansharma.in/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://kishansharma.in/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://kishansharma.in/series/" title="Series">
                    <span>Series</span>
                </a>
            </li>
            <li>
                <a href="http://kishansharma.in/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://kishansharma.in/">Home</a>&nbsp;»&nbsp;<a href="http://kishansharma.in/posts/">Posts</a></div>
    <h1 class="post-title">
      Postgres Performance Tuning Manual: Query Plans
    </h1>
    <div class="post-description">
      Is Postgres slowing down on you? Here&#39;s how to identify areas of improvement using query plans
    </div>
    <div class="post-meta">&lt;span title=&#39;2023-03-26 00:11:32 &#43;0530 IST&#39;&gt;March 26, 2023&lt;/span&gt;&amp;nbsp;·&amp;nbsp;6 min&amp;nbsp;·&amp;nbsp;Kishan Sharma

</div>
  </header>

<div>
    <p><small> This is a post 📖 in the</small>
         <strong> <a href='/series/tuning-postgres-using-indexes'> Tuning Postgres using Indexes</a> </strong>
    <small>series. </small>  </p>
    <ul class="post-content h3">
        
            
                <li class="post-description">
                    Part 1: This Article - Postgres Performance Tuning Manual: Query Plans 
                </li>
            
        
            
                <li class="post-description">
                    <a href="http://kishansharma.in/posts/postgres-performance-tuning-manualindexes/">
                        Part 2: Postgres Performance Tuning Manual: Indexes
                    </a>
                </li>
            
        
    </ul>
</div>
 
<figure class="entry-cover"><a href="http://kishansharma.in/img/elephant-postgres.jpg" target="_blank"
            rel="noopener noreferrer"><img loading="lazy" src="http://kishansharma.in/img/elephant-postgres.jpg" alt=""></a>
        
</figure><div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#meet-explain-analyze" aria-label="Meet EXPLAIN &amp;amp; ANALYZE">Meet EXPLAIN &amp; ANALYZE</a></li>
                <li>
                    <a href="#finding-the-framework" aria-label="Finding the framework">Finding the framework</a></li>
                <li>
                    <a href="#planner-cost-constants" aria-label="Planner cost constants">Planner cost constants</a></li>
                <li>
                    <a href="#down-to-the-nuts-andbolts" aria-label="Down to the nuts and bolts">Down to the nuts and bolts</a><ul>
                        
                <li>
                    <a href="#bitmap-heap-scan" aria-label="Bitmap heap scan">Bitmap heap scan</a></li>
                <li>
                    <a href="#sequential-scan-vs-index-scan" aria-label="Sequential scan vs index scan">Sequential scan vs index scan</a></li></ul>
                </li>
                <li>
                    <a href="#query-plan-onjoins" aria-label="Query plan on JOINS">Query plan on JOINS</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Postgres is one of the most widely used open source databases in the world. At GOJEK, a lot of our products depend on Postgres as well. A lot of major companies use Postgres as their main database however when you&rsquo;re building and operating at scale, the volume of data passing through the pipelines can slow down the most efficient systems.</p>
<p>To optimise things in order to enhace performace, we can target the brain of the database whhich is <em>optimizer</em>. Optimizer interprets queries and determines the fastest method of execution. A single query optimization technique can increase database performance drastically.</p>
<p><img loading="lazy" src="/img/postgres-query-lifecycle.png" alt="postgres query lifecycle"  />
</p>
<p>This post outlines how to analyse Postgres performance using tools such as EXPLAIN and ANALYZE (which Postgres provides).</p>
<h2 id="meet-explain-analyze">Meet EXPLAIN &amp; ANALYZE<a hidden class="anchor" aria-hidden="true" href="#meet-explain-analyze">#</a></h2>
<p><code>EXPLAIN</code> gives an exact breakdown of a query. The execution plan is based on the statistics about the table, and it identifies the most efficient path to the data. This takes different database paradigms (such as indexes) into consideration. <code>EXPLAIN</code> only guesses a plan that it thinks it will execute.
This is where <code>ANALYZE</code> comes into the picture. <code>ANALYZE</code> basically runs a query to find the processing time to execute a query.</p>
<p>To quickly summarise, <code>EXPLAIN</code> and <code>ANALYZE</code> commands help improve database performance in Postgres by:</p>
<blockquote>
<p>a. <em>Displaying the execution plan that the PostgreSQL planner generates for the supplied statement.</em></p>
<p>b. <em>Actually running the command to show the run time.</em></p>
</blockquote>
<h2 id="finding-the-framework">Finding the framework<a hidden class="anchor" aria-hidden="true" href="#finding-the-framework">#</a></h2>
<p>Let&rsquo;s consider we have a table named <code>schemes</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> schemes;
</span></span></code></pre></div><blockquote>
<p><em>QUERY PLAN | Seq Scan on schemes (cost=0.00..64 rows=328 width=479)</em></p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> pg_class <span style="color:#66d9ef">where</span> relname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;schemes&#39;</span>;
</span></span></code></pre></div><p><code>pg_class</code> has the metadata about the tables.</p>
<p>Cost in the query plan is calculated using the following formula</p>
<blockquote>
<p><em>COST = (disk read pages x seq_page_cost) + (rows scanned x cpu_tuple_cost).</em></p>
</blockquote>
<ul>
<li>Disk read pages and rows scanned are the properties of <code>pg_class</code>.</li>
<li>Seq page cost is the estimated cost of disk read fetch.</li>
<li>Cpu tuple cost is the estimated cost of processing each row.
eg., COST (54 x 1.0) + (1000 x .01) = 64</li>
</ul>
<p>Let&rsquo;s see how the query plan changes when we apply filters in the select statement.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> schemes <span style="color:#66d9ef">WHERE</span> status <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;active&#39;</span>;
</span></span></code></pre></div><blockquote>
<p><em>QUERY PLAN | Seq Scan on schemes (cost=0.00..66.50 rows=960 width=384) Filter: ((status)::text = &lsquo;active&rsquo;::text)</em></p>
</blockquote>
<p>The estimated cost here is higher than the previous query, this is because Postgres is performing a seq scan over 1000 rows first and then filtering out the rows based on the <code>WHERE</code> clause.</p>
<h2 id="planner-cost-constants">Planner cost constants<a hidden class="anchor" aria-hidden="true" href="#planner-cost-constants">#</a></h2>
<p>The cost variables described in this section are measured on an arbitrary scale. Only their relative values matter, hence scaling them all up or down by the same factor will result in no change in the planner&rsquo;s choices. By default, these cost variables are based on the cost of sequential page fetches; that is, seq_page_cost is conventionally set to 1.0 and the other cost variables are set with reference to that. But you can use a different scale if you prefer, such as actual execution times in milliseconds on a particular machine.</p>
<p>Unfortunately, there is no well-defined method for determining ideal values for the cost variables. They are best treated as averages over the entire mix of queries that a particular installation will receive. This means that changing them on the basis of just a few experiments is very risky. <a href="https://www.postgresql.org/docs/current/runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS">Refer planner cost constants</a>].</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> schemes.rules <span style="color:#66d9ef">FROM</span> scheme_rules <span style="color:#66d9ef">JOIN</span> schemes <span style="color:#66d9ef">ON</span> (scheme_rules.scheme_id <span style="color:#f92672">=</span> schemes.id ) <span style="color:#66d9ef">where</span> scheme_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;weekend_scheme&#39;</span>;
</span></span></code></pre></div><p>The query planner sometimes decides to use a two-step plan. The reason for using two-plan node is the first plan sorts the row locations identified by the index into physical order before reading them, and the other plan actually fetches those rows from the table.</p>
<h2 id="down-to-the-nuts-andbolts">Down to the nuts and bolts<a hidden class="anchor" aria-hidden="true" href="#down-to-the-nuts-andbolts">#</a></h2>
<p>The first plan which does the sorting is called Bitmap scan.</p>
<p>Most common occurring matches are scanned using the <code>seq scan</code> and the least common matches are scanned using <code>index scan</code>, anything in between is scanned using <code>bitmap heap scan</code> followed by an <code>index scan</code>. One of the reasons for this is that the random I/O is very slow as compared to sequential I/O. This is all driven by analysing statistics.</p>
<h3 id="bitmap-heap-scan">Bitmap heap scan<a hidden class="anchor" aria-hidden="true" href="#bitmap-heap-scan">#</a></h3>
<p>A <a href="https://www.postgresql.org/docs/8.1/performance-tips.html">bitmap heap scan</a> is like a seq scan - the difference being, rather than visiting every disk page, it scans ANDs and ORs of the applicable index together and only visits the disk pages it needs to visit. This is different from index scan where the index is visited row by row in order, which results in disk pages being visited multiple times. A bitmap scan will sequentially open a short list of disk pages and grab every applicable row in each one.</p>
<h3 id="sequential-scan-vs-index-scan">Sequential scan vs index scan<a hidden class="anchor" aria-hidden="true" href="#sequential-scan-vs-index-scan">#</a></h3>
<p>There are cases where a sequential scan is faster than an index scan. When reading data from a disk, a sequential method is usually faster than reading in random order. This is because an index scan requires several I/O for each row which includes looking up a row in the index, and based on that, looking up and retrieving the row from memory(heap). On the other hand, a sequential scan requires a single I/O operation to retrieve more than one block containing multiple rows.</p>
<h2 id="query-plan-onjoins">Query plan on JOINS<a hidden class="anchor" aria-hidden="true" href="#query-plan-onjoins">#</a></h2>
<p>The optimizer needs to pick the correct join algorithm when there are multiple tables to be joined in the select statement. Postgres uses three different kinds of join algorithms based on the type of join we are using.</p>
<blockquote>
<p><em>Let&rsquo;s dive in</em></p>
</blockquote>
<p><strong>Nested Loop</strong>: Here the planner can use either a sequential scan or index scan for each of the elements in the first table. The planner uses a sequential scan when the second table is small. The basic logic of choosing between a sequential scan and index scan applies here too.
<strong>Hash Join</strong>: In this algorithm, the planner creates a hash table of the smaller table on the join key. The larger table is then scanned, searching the hash table for the rows which meet the join condition. This requires a lot of memory to store the hash table in the first place.
<strong>Merge Join</strong>: This is similar to merge sort algorithm. Here the planner sorts both the tables to be joined on the join attribute. The tables are then scanned in parallel to find the matching values.</p>
<blockquote>
<p>Further reading on how we can use Explain/Analyze with join statements <a href="https://www.postgresql.org/docs/11/using-explain.html#USING-EXPLAIN-ANALYZE">here</a></p>
</blockquote>
<p>Postgres performance tuning is a complicated task. The complexity comes in identifying the appropriate &rsquo;tunable&rsquo; from the many tools that Postgres provides. As you might have now guessed, there is no silver bullet to solving performance issues in Postgres - it&rsquo;s the use case that dictates the tuning requirements. 😅</p>
<p>Hope this helped. Keep following the blog for more updates! 🙂</p>


  </div>

<div>
    <p><small> This is a post 📖 in the</small>
         <strong> <a href='/series/tuning-postgres-using-indexes'> Tuning Postgres using Indexes</a> </strong>
    <small>series. </small>  </p>
    <ul class="post-content h3">
        
            
                <li class="post-description">
                    Part 1: This Article - Postgres Performance Tuning Manual: Query Plans 
                </li>
            
        
            
                <li class="post-description">
                    <a href="http://kishansharma.in/posts/postgres-performance-tuning-manualindexes/">
                        Part 2: Postgres Performance Tuning Manual: Indexes
                    </a>
                </li>
            
        
    </ul>
</div>


  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://kishansharma.in/tags/postgres/">postgres</a></li>
      <li><a href="http://kishansharma.in/tags/query-plans/">query-plans</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://kishansharma.in/posts/postgres-performance-tuning-manualindexes/">
    <span class="title">« Prev</span>
    <br>
    <span>Postgres Performance Tuning Manual: Indexes</span>
  </a>
  <a class="next" href="http://kishansharma.in/posts/extend-cidr/">
    <span class="title">Next »</span>
    <br>
    <span>Extend CIDR</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Query Plans on twitter"
        href="https://twitter.com/intent/tweet/?text=Postgres%20Performance%20Tuning%20Manual%3a%20Query%20Plans&amp;url=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualquery-plans%2f&amp;hashtags=postgres%2cquery-plans">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Query Plans on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualquery-plans%2f&amp;title=Postgres%20Performance%20Tuning%20Manual%3a%20Query%20Plans&amp;summary=Postgres%20Performance%20Tuning%20Manual%3a%20Query%20Plans&amp;source=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualquery-plans%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Query Plans on reddit"
        href="https://reddit.com/submit?url=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualquery-plans%2f&title=Postgres%20Performance%20Tuning%20Manual%3a%20Query%20Plans">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Query Plans on facebook"
        href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualquery-plans%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Query Plans on whatsapp"
        href="https://api.whatsapp.com/send?text=Postgres%20Performance%20Tuning%20Manual%3a%20Query%20Plans%20-%20http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualquery-plans%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Query Plans on telegram"
        href="https://telegram.me/share/url?text=Postgres%20Performance%20Tuning%20Manual%3a%20Query%20Plans&amp;url=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualquery-plans%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer><script src="https://giscus.app/client.js"
        data-repo="kshnsink/kshnsink.github.io"
        data-repo-id="R_kgDOJLcmGA"
        data-category="General"
        data-category-id="DIC_kwDOJLcmGM4CWF88"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="dark_high_contrast"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://kishansharma.in/">Kishan&#39;s World</a></span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
