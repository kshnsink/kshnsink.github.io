<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Postgres Performance Tuning Manual: Indexes | Kishan&#39;s World</title>
<meta name="keywords" content="postgres, index">
<meta name="description" content="How to modify and improve query times in Postgres with the help of indexes.">
<meta name="author" content="Kishan Sharma">
<link rel="canonical" href="http://kishansharma.in/posts/postgres-performance-tuning-manualindexes/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8e51cb336ebfd68fa90498124f4cb72a9201dce3a0d02d729ef5652a2d5e9049.css" integrity="sha256-jlHLM26/1o&#43;pBJgST0y3KpIB3OOg0C1ynvVlKi1ekEk=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://kishansharma.in/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://kishansharma.in/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://kishansharma.in/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://kishansharma.in/apple-touch-icon.png">
<link rel="mask-icon" href="http://kishansharma.in/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Postgres Performance Tuning Manual: Indexes" />
<meta property="og:description" content="How to modify and improve query times in Postgres with the help of indexes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://kishansharma.in/posts/postgres-performance-tuning-manualindexes/" />
<meta property="og:image" content="http://kishansharma.in/img/postgres-index-cover.jpg" /><meta property="article:section" content="posts" />


<meta property="og:see_also" content="http://kishansharma.in/posts/postgres-performance-tuning-manualquery-plans/" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://kishansharma.in/img/postgres-index-cover.jpg" />
<meta name="twitter:title" content="Postgres Performance Tuning Manual: Indexes"/>
<meta name="twitter:description" content="How to modify and improve query times in Postgres with the help of indexes."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://kishansharma.in/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Postgres Performance Tuning Manual: Indexes",
      "item": "http://kishansharma.in/posts/postgres-performance-tuning-manualindexes/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Postgres Performance Tuning Manual: Indexes",
  "name": "Postgres Performance Tuning Manual: Indexes",
  "description": "How to modify and improve query times in Postgres with the help of indexes.",
  "keywords": [
    "postgres", "index"
  ],
  "articleBody": "In this post, we look at how to overcome slow queries by analysing them with Explain and Analyze, and using indexes to modify and enhance the query timings.\nPostgres supports different kinds of indexing on the table for querying faster.\nMultiple column indexes A multi-column B-Tree index can be used with query conditions that involve any subset of the index’s columns. This index is most efficient when there are constraints on the leading (leftmost) columns. The exact rule is that equality constraints on leading columns, plus any inequality constraints on the first column that does not have an equality constraint, will be used to limit the portion of the index that is scanned.\nCover-Index An index containing all the columns needed for a query, which is there in the select statement.\nUnique Index A unique index is an index used to enforce uniqueness of a column’s value or the uniqueness of a combined value of more than one column.\nOne of the most misunderstood concepts around indexing is to understand where to use a primary key, unique constraint, or unique index. Let’s understand this using a problem:\nProblem statement We require maximum performance with no duplicate data. Which is the better approach? Primary key, unique constraint or unique index?\nSolution Note: Multiple null values are not equal, so they are not considered as a duplicate record.\nPostgres automatically creates a unique index in the table when a primary key and unique constraint is defined in the table. Creating unique constraint then would be redundant, and unnecessarily creating indexes degrades the performance of Postgres. According to suggestions by the Postgres product team, create a unique constraint on the table and then there is no need to create a unique index on those columns. Postgres creates an index for the defined primary key itself When we create a unique constraint, Postgres automatically creates an index behind the scene. However, there are cases where even indexing can’t improve performance. One such case is when we do case-insensitive searches. Let’s understand the difference between the query cost in case of case sensitive and case insensitive search in our scheme table. Given we have an index on the column scheme_name.\nEXPLAIN ANALYSE SELECT * FROM schemes where scheme_name = 'weekend_scheme' QUERY PLAN | Index scan using idx_scheme_name on schemes (cost=0.28..8.29 rows=1 width=384) Planning Time: 0.155 ms Execution Time: 0.063ms\nEXPLAIN ANALYSE SELECT * FROM schemes where lower(scheme_name) = 'weekend_scheme' QUERY PLAN | Seq Scan on schemes (cost=0.00..69.00 rows=5 width=384) Filter: (lower((scheme_name) :: text) = ‘weekend_scheme’ :: text) Rows removed by filter: 999 Planning Time: 0.119 ms Execution Time: 0.721ms\nEven though we have an index created at scheme_name, the function lower degrades the performance as it does an additional effort of converting all the values of scheme_table to lower case.\nCases when an index is not used (although it is defined).\nLIKE '%scheme' will never use an index, but LIKE 'scheme%' can possibly use the index. The upper/lower case function used in where clause. So whenever we want to use a function in our where clause, we could create the index in the following way to optimise the query.\nCREATE INDEX idx_scheme_name ON schemes (lower(scheme_name)) EXPLAIN ANALYSE SELECT * FROM schemes where lower(scheme_name) = 'weekend_scheme' QUERY PLAN | Bitmap heap scan on schemes ((cost=4.32..19.83 rows=5 width=384)) Recheck cond: (lower ((scheme_name) :: text) = ‘weekend_scheme’ :: text) Heap Blocks: exact=1 Bitmap scan on schemes ((cost=0.00..4.32 rows=5 width=0)) Index cond: (lower ((scheme_name) :: text) = ‘weekend_scheme’ :: text) Planning Time: 1.784 ms Execution Time: 0.079 ms\nPartial Index Postgres supports an index over a subset of the rows of a table (known as a partial index). It’s often the best way to index our data if we want to repeatedly analyse rows that match a given WHERE clause. Let us see how we can enhance the performance of Postgres using partial indexing.\nProblem statement We want to return all the schemes which are supposed to run before 11:00 am.\nSolution EXPLAIN ANALYSE SELECT * FROM schemes WHERE start_time \u003c '10:00:00' QUERYEXPLAIN ANALYSE SELECT * FROM schemes where lower(scheme_name) = ‘weekend_scheme’ PLAN | Seq Scan on schemes (cost=0.00..66.50 rows=9 width=23) Filter: (start_time \u003c ‘10:00:00’) Rows removed by filter: 991 Planning Time: 0.082 ms Execution Time: 0.226 ms\nWe can create an index on start_time column but assuming we have a huge database, this may not be optimal for insert, update and delete. So we create an index with a condition. This kind of indexing is used when we know what we need from our select queries. Say we do a heavy read on all the schemes which are started before 10:00:00 and not much when started later.\nCREATE INDEX idx_scheme_name ON schemes start_time WHERE start_time \u003c '11:00:00' EXPLAIN ANALYSE SELECT * FROM schemes WHERE start_time \u003c '10:00:00' QUERY PLAN | Bitmap heap scan on schemes ((cost=4.21..29.30 rows=9 width=23)) Recheck cond: (start_time \u003c ‘10:00:00’) Heap Blocks: exact=8 Bitmap index scan on schemes ((cost=0.00..4.21 rows=9 width=0) Index cond: (start_time \u003c ‘10:00:00’) Planning Time: 1.729 ms Execution Time: 0.075 ms\nThis reduces the execution time from 0.226to 0.075. Let’s validate that we have not indexed all the schemes where start_time is after 11:00 AM.\nEXPLAIN ANALYSE SELECT * FROM schemes WHERE start_time \u003e'12:00:00' QUERY PLAN | Seq Scan on schemes (cost=0.00..66.50 rows=6 width=23) Filter: (start_time \u003c ‘12:00:00’) Rows removed by filter: 993 Planning Time: 0.101 ms Execution Time: 0.228ms\nThis proves that partial data from schemes table is indexed and the rest of the data is not indexed. Our index size is very small and easy to maintain, helping in the maintaining task of reindexing.\nQuery plan on JOINS The optimizer needs to pick the correct join algorithm when there are multiple tables to be joined in the select statement. Postgres uses 3 different kinds of join algorithm based on the type of join we are using.\nNested Loop: Here, the planner can use either sequential scan or index scan for each of the elements in the first table. The planner uses a sequential scan when the second table is small. The basic logic of choosing between a sequential scan and index scan applies here too. Hash Join: In this algorithm, the planner creates a hash table of the smaller table on the join key. The larger table is then scanned, searching the hash table for the rows which meet the join condition. This requires a lot of memory to store the hash table in the first place. Merge Join: This is similar to merge sort algorithm. Here the planner sorts both the tables to be joined on the join attribute. The tables are then scanned in parallel to find the matching values.\nEXPLAIN SELECT schemes.rules FROM scheme_rules JOIN schemes ON (scheme_rules.scheme_id = schemes.id ) where scheme_name = 'weekend_scheme'; Downsides of indexes in production environments Finding unused indexes In a large production environment, finding unused indexes is advisable, because indexes eat memory. Postgres wiki page details how we can find index summary, duplicate indexes, and index size.\nCREATE/DROP index vs CREATE/DROP index concurrently Creating and dropping an index in a large database can take hours or even days and the CREATE INDEX command blocks all the writes on a table (it doesn’t block the reads, but this is still not ideal).\nHowever, an index created concurrently with CREATE INDEX CONCURRENT will not acquire locks against writes. When creating index concurrently, Postgres first scans the table to build indexes and runs the index once again for the things to be added since the first pass.\nCreating an index concurrently also has a downside though. If something goes wrong during the process, it does not roll back, and leaves an invalid index behind. Invalid indexes can be found using the following query.\nSELECT * FROM pg_class, pg_index WHERE pg_index.indisvalid = false AND pg_index.indexrelid = pg_class.oid; Rebuilding indexes REINDEX rebuilds an index using the data stored in the index table, replacing the old copy of the index. If we suspect corruption of an index on a table, we can simply rebuild that index, or all indexes on the table, using REINDEX INDEX or REINDEX TABLE\nREINDEX is similar to a drop and recreate of the index in that the index contents are rebuilt from scratch. However, locking considerations are rather different. REINDEX locks out writes but not reads of the index’s parent table. It also takes an exclusive lock on the specific index being processed, which will block reads that attempt to use that index.\nAnother option is to drop index concurrently and create again concurrently.\nConclusion This post aimed to provide an overview of how Postgres queries the database. By understanding query plans better and carefully taking measures (mostly through indexes), we can get the best performance out of the Postgres database.\nFurther Reading Index locking consideration Locking indexes Routine reindexing Examining index usage Monitoring stats ",
  "wordCount" : "1473",
  "inLanguage": "en",
  "image":"http://kishansharma.in/img/postgres-index-cover.jpg","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "Kishan Sharma"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://kishansharma.in/posts/postgres-performance-tuning-manualindexes/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kishan's World",
    "logo": {
      "@type": "ImageObject",
      "url": "http://kishansharma.in/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://kishansharma.in/" accesskey="h" title="Kishan Sharma (Alt + H)">Kishan Sharma</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://kishansharma.in/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://kishansharma.in/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://kishansharma.in/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://kishansharma.in/series/" title="Series">
                    <span>Series</span>
                </a>
            </li>
            <li>
                <a href="http://kishansharma.in/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://kishansharma.in/">Home</a>&nbsp;»&nbsp;<a href="http://kishansharma.in/posts/">Posts</a></div>
    <h1 class="post-title">
      Postgres Performance Tuning Manual: Indexes
    </h1>
    <div class="post-description">
      How to modify and improve query times in Postgres with the help of indexes.
    </div>
    <div class="post-meta">Kishan Sharma

</div>
  </header>

<div>
    <p><small> This is a post 📖 in the</small>
         <strong> <a href='/series/tuning-postgres-using-indexes'> Tuning Postgres using Indexes</a> </strong>
    <small>series. </small>  </p>
    <ul class="post-content h3">
        
            
                <li class="post-description">
                    Part 1: This Article - Postgres Performance Tuning Manual: Indexes 
                </li>
            
        
            
                <li class="post-description">
                    <a href="http://kishansharma.in/posts/postgres-performance-tuning-manualquery-plans/">
                        Part 2: Postgres Performance Tuning Manual: Query Plans
                    </a>
                </li>
            
        
    </ul>
</div>
 
<figure class="entry-cover"><a href="http://kishansharma.in/img/postgres-index-cover.jpg" target="_blank"
            rel="noopener noreferrer"><img loading="lazy" src="http://kishansharma.in/img/postgres-index-cover.jpg" alt=""></a>
        
</figure><div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#multiple-columnindexes" aria-label="Multiple column indexes">Multiple column indexes</a><ul>
                        
                <li>
                    <a href="#cover-index" aria-label="Cover-Index">Cover-Index</a></li>
                <li>
                    <a href="#unique-index" aria-label="Unique Index">Unique Index</a><ul>
                        
                <li>
                    <a href="#problem-statement" aria-label="Problem statement">Problem statement</a></li>
                <li>
                    <a href="#solution" aria-label="Solution">Solution</a></li></ul>
                </li>
                <li>
                    <a href="#partial-index" aria-label="Partial Index">Partial Index</a><ul>
                        
                <li>
                    <a href="#problem-statement-1" aria-label="Problem statement">Problem statement</a></li>
                <li>
                    <a href="#solution-1" aria-label="Solution">Solution</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#query-plan-onjoins" aria-label="Query plan on JOINS">Query plan on JOINS</a></li>
                <li>
                    <a href="#downsides-of-indexes-in-production-environments" aria-label="Downsides of indexes in production environments">Downsides of indexes in production environments</a><ul>
                        
                <li>
                    <a href="#finding-unusedindexes" aria-label="Finding unused indexes">Finding unused indexes</a></li>
                <li>
                    <a href="#createdrop-index-vs-createdrop-index-concurrently" aria-label="CREATE/DROP index vs CREATE/DROP index concurrently">CREATE/DROP index vs CREATE/DROP index concurrently</a></li>
                <li>
                    <a href="#rebuilding-indexes" aria-label="Rebuilding indexes">Rebuilding indexes</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#further-reading" aria-label="Further Reading">Further Reading</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>In this post, we look at how to overcome slow queries by analysing them with <code>Explain</code> and <code>Analyze</code>, and using indexes to modify and enhance the query timings.</p>
<p>Postgres supports different kinds of indexing on the table for
querying faster.</p>
<h2 id="multiple-columnindexes">Multiple column indexes<a hidden class="anchor" aria-hidden="true" href="#multiple-columnindexes">#</a></h2>
<p>A <a href="https://www.postgresql.org/docs/9.6/indexes-multicolumn.html">multi-column B-Tree index</a> can be used with query conditions that involve any subset of the index&rsquo;s columns. This index is most efficient when there are constraints on the leading (leftmost) columns. The exact rule is that equality constraints on leading columns, plus any inequality constraints on the first column that does not have an equality constraint, will be used to limit the portion of the index that is scanned.</p>
<h3 id="cover-index">Cover-Index<a hidden class="anchor" aria-hidden="true" href="#cover-index">#</a></h3>
<p>An index containing all the columns needed for a query, which is there in the select statement.</p>
<h3 id="unique-index">Unique Index<a hidden class="anchor" aria-hidden="true" href="#unique-index">#</a></h3>
<p>A unique index is an index used to enforce uniqueness of a column&rsquo;s value or the uniqueness of a combined value of more than one column.</p>
<blockquote>
<p>One of the most misunderstood concepts around indexing is to understand where to use a primary key, unique constraint, or unique index. Let&rsquo;s understand this using a problem:</p>
</blockquote>
<h4 id="problem-statement">Problem statement<a hidden class="anchor" aria-hidden="true" href="#problem-statement">#</a></h4>
<p>We require maximum performance with no duplicate data. Which is the better approach? Primary key, unique constraint or unique index?</p>
<p><img loading="lazy" src="/img/postgres-index-thinking.jpeg" alt=" "  />
</p>
<h4 id="solution">Solution<a hidden class="anchor" aria-hidden="true" href="#solution">#</a></h4>
<blockquote>
<p><em>Note: Multiple null values are not equal, so they are not considered as a duplicate record.</em></p>
</blockquote>
<ul>
<li>Postgres automatically creates a <a href="https://www.postgresql.org/docs/9.4/indexes-unique.html">unique index</a> in the table when a primary key and unique constraint is defined in the table. Creating unique constraint then would be redundant, and unnecessarily creating indexes degrades the performance of Postgres. According to suggestions by the Postgres product team, create a unique constraint on the table and then there is no need to create a unique index on those columns.</li>
<li>Postgres creates an index for the defined primary key itself</li>
<li>When we create a unique constraint, Postgres automatically creates an index behind the scene.</li>
</ul>
<p>However, there are cases where even indexing can&rsquo;t improve performance. One such case is when we do case-insensitive searches. Let&rsquo;s understand the difference between the query cost in case of <em>case sensitive</em> and <em>case insensitive</em> search in our scheme table. Given we have an index on the column <code>scheme_name</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYSE</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> schemes <span style="color:#66d9ef">where</span> scheme_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;weekend_scheme&#39;</span> 
</span></span></code></pre></div><blockquote>
<p>QUERY PLAN | Index scan using idx_scheme_name on schemes
(cost=0.28..8.29 rows=1 width=384)
Planning Time: 0.155 ms
Execution Time: 0.063ms</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYSE</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> schemes <span style="color:#66d9ef">where</span> <span style="color:#66d9ef">lower</span>(scheme_name) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;weekend_scheme&#39;</span> 
</span></span></code></pre></div><blockquote>
<p>QUERY PLAN | Seq Scan on schemes (cost=0.00..69.00 rows=5 width=384)
Filter: (lower((scheme_name) :: text) = &lsquo;weekend_scheme&rsquo; :: text)
Rows removed by filter: 999
Planning Time: 0.119 ms
Execution Time: 0.721ms</p>
</blockquote>
<p>Even though we have an index created at <code>scheme_name</code>, the function <code>lower</code> degrades the performance as it does an additional effort of converting all the values of <code>scheme_table</code> to lower case.</p>
<p>Cases when an index is not used (although it is defined).</p>
<ul>
<li>LIKE <code>'%scheme'</code> will never use an index, but LIKE <code>'scheme%'</code> can possibly use the index.</li>
<li>The upper/lower case function used in <code>where</code> clause.</li>
</ul>
<p>So whenever we want to use a function in our where clause, we could create the index in the following way to optimise the query.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_scheme_name <span style="color:#66d9ef">ON</span> schemes (<span style="color:#66d9ef">lower</span>(scheme_name)) 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYSE</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> schemes <span style="color:#66d9ef">where</span> <span style="color:#66d9ef">lower</span>(scheme_name) <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;weekend_scheme&#39;</span>
</span></span></code></pre></div><blockquote>
<p>QUERY PLAN | Bitmap heap scan on schemes ((cost=4.32..19.83 rows=5 width=384))
Recheck cond: (lower ((scheme_name) :: text) = &lsquo;weekend_scheme&rsquo; :: text)
Heap Blocks: exact=1
Bitmap scan on schemes ((cost=0.00..4.32 rows=5 width=0))
Index cond: (lower ((scheme_name) :: text) = &lsquo;weekend_scheme&rsquo; :: text)
Planning Time: 1.784 ms
Execution Time: 0.079 ms</p>
</blockquote>
<h3 id="partial-index">Partial Index<a hidden class="anchor" aria-hidden="true" href="#partial-index">#</a></h3>
<p>Postgres supports an index over a subset of the rows of a table (known as a partial index). It&rsquo;s often the best way to index our data if we want to repeatedly analyse rows that match a given <code>WHERE</code> clause. Let us see how we can enhance the performance of Postgres using partial indexing.</p>
<h4 id="problem-statement-1">Problem statement<a hidden class="anchor" aria-hidden="true" href="#problem-statement-1">#</a></h4>
<p>We want to return all the schemes which are supposed to run before 11:00 am.</p>
<h4 id="solution-1">Solution<a hidden class="anchor" aria-hidden="true" href="#solution-1">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYSE</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> schemes <span style="color:#66d9ef">WHERE</span> start_time <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;10:00:00&#39;</span>
</span></span></code></pre></div><blockquote>
<p>QUERYEXPLAIN ANALYSE SELECT * FROM schemes where lower(scheme_name) = &lsquo;weekend_scheme&rsquo; PLAN | Seq Scan on schemes (cost=0.00..66.50 rows=9 width=23)
Filter: (start_time &lt; &lsquo;10:00:00&rsquo;)
Rows removed by filter: 991
Planning Time: 0.082 ms
Execution Time: 0.226 ms</p>
</blockquote>
<p>We can create an index on <code>start_time</code> column but assuming we have a huge database, this may not be optimal for insert, update and delete. So we create an index with a condition. This kind of indexing is used when we know what we need from our select queries. Say we do a heavy read on all the schemes which are started before 10:00:00 and not much when started later.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_scheme_name <span style="color:#66d9ef">ON</span> schemes start_time <span style="color:#66d9ef">WHERE</span> start_time <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;11:00:00&#39;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYSE</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> schemes <span style="color:#66d9ef">WHERE</span> start_time <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#39;10:00:00&#39;</span>
</span></span></code></pre></div><blockquote>
<p>QUERY PLAN | Bitmap heap scan on schemes ((cost=4.21..29.30 rows=9 width=23))
Recheck cond: (start_time &lt; &lsquo;10:00:00&rsquo;)
Heap Blocks: exact=8
Bitmap index scan on schemes ((cost=0.00..4.21 rows=9 width=0)
Index cond: (start_time &lt; &lsquo;10:00:00&rsquo;)
Planning Time: 1.729 ms
Execution Time: 0.075 ms</p>
</blockquote>
<p>This reduces the execution time from 0.226to 0.075.
Let&rsquo;s validate that we have not indexed all the schemes where start_time is after 11:00 AM.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">ANALYSE</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> schemes <span style="color:#66d9ef">WHERE</span> start_time <span style="color:#f92672">&gt;</span><span style="color:#e6db74">&#39;12:00:00&#39;</span>
</span></span></code></pre></div><blockquote>
<p>QUERY PLAN | Seq Scan on schemes (cost=0.00..66.50 rows=6 width=23)
Filter: (start_time &lt; &lsquo;12:00:00&rsquo;)
Rows removed by filter: 993
Planning Time: 0.101 ms
Execution Time: 0.228ms</p>
</blockquote>
<p>This proves that partial data from schemes table is indexed and the rest of the data is not indexed. Our index size is very small and easy to maintain, helping in the maintaining task of reindexing.</p>
<h2 id="query-plan-onjoins">Query plan on JOINS<a hidden class="anchor" aria-hidden="true" href="#query-plan-onjoins">#</a></h2>
<p>The optimizer needs to pick the correct join algorithm when there are multiple tables to be joined in the select statement. Postgres uses 3 different kinds of join algorithm based on the type of join we are using.</p>
<p><strong>Nested Loop</strong>: Here, the planner can use either sequential scan or index scan for each of the elements in the first table. The planner uses a sequential scan when the second table is small. The basic logic of choosing between a sequential scan and index scan applies here too.
<strong>Hash Join</strong>: In this algorithm, the planner creates a hash table of the smaller table on the join key. The larger table is then scanned, searching the hash table for the rows which meet the join condition. This requires a lot of memory to store the hash table in the first place.
<strong>Merge Join</strong>: This is similar to merge sort algorithm. Here the planner sorts both the tables to be joined on the join attribute. The tables are then scanned in parallel to find the matching values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">EXPLAIN</span> <span style="color:#66d9ef">SELECT</span> schemes.rules <span style="color:#66d9ef">FROM</span> scheme_rules <span style="color:#66d9ef">JOIN</span> schemes <span style="color:#66d9ef">ON</span> (scheme_rules.scheme_id <span style="color:#f92672">=</span> schemes.id ) <span style="color:#66d9ef">where</span> scheme_name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;weekend_scheme&#39;</span>;
</span></span></code></pre></div><h2 id="downsides-of-indexes-in-production-environments">Downsides of indexes in production environments<a hidden class="anchor" aria-hidden="true" href="#downsides-of-indexes-in-production-environments">#</a></h2>
<h3 id="finding-unusedindexes">Finding unused indexes<a hidden class="anchor" aria-hidden="true" href="#finding-unusedindexes">#</a></h3>
<p>In a large production environment, finding unused indexes is advisable, because indexes eat memory. <a href="https://wiki.postgresql.org/wiki/Index_Maintenance">Postgres wiki page</a> details how we can find index summary, duplicate indexes, and index size.</p>
<h3 id="createdrop-index-vs-createdrop-index-concurrently">CREATE/DROP index vs CREATE/DROP index concurrently<a hidden class="anchor" aria-hidden="true" href="#createdrop-index-vs-createdrop-index-concurrently">#</a></h3>
<p>Creating and dropping an index in a large database can take hours or even days and the <code>CREATE INDEX</code> command blocks all the writes on a table (it doesn&rsquo;t block the reads, but this is still not ideal).</p>
<p>However, an index created concurrently with <code>CREATE INDEX</code> CONCURRENT will not acquire locks against writes. When creating index concurrently, Postgres first scans the table to build indexes and runs the index once again for the things to be added since the first pass.</p>
<p>Creating an index concurrently also has a downside though. If something goes wrong during the process, it does not roll back, and leaves an invalid index behind. Invalid indexes can be found using the following query.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> pg_class, pg_index <span style="color:#66d9ef">WHERE</span> pg_index.indisvalid <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span> <span style="color:#66d9ef">AND</span> pg_index.indexrelid <span style="color:#f92672">=</span> pg_class.oid;
</span></span></code></pre></div><h3 id="rebuilding-indexes">Rebuilding indexes<a hidden class="anchor" aria-hidden="true" href="#rebuilding-indexes">#</a></h3>
<p><a href="https://www.postgresql.org/docs/current/sql-reindex.html">REINDEX</a> rebuilds an index using the data stored in the index table, replacing the old copy of the index. If we suspect corruption of an index on a table, we can simply rebuild that index, or all indexes on the table, using <code>REINDEX INDEX</code> or <code>REINDEX TABLE</code></p>
<p>REINDEX is similar to a drop and recreate of the index in that the index contents are rebuilt from scratch. However, locking considerations are rather different. REINDEX locks out writes but not reads of the index&rsquo;s parent table. It also takes an exclusive lock on the specific index being processed, which will block reads that attempt to use that index.</p>
<blockquote>
<p>Another option is to drop index concurrently and create again concurrently.</p>
</blockquote>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>This post aimed to provide an overview of how Postgres queries the database. By understanding query plans better and carefully taking measures (mostly through indexes), we can get the best performance out of the Postgres database.</p>
<h2 id="further-reading">Further Reading<a hidden class="anchor" aria-hidden="true" href="#further-reading">#</a></h2>
<ul>
<li><a href="https://www.postgresql.org/docs/8.1/index-locking.html">Index locking consideration</a></li>
<li><a href="https://www.postgresql.org/docs/8.4/locking-indexes.html">Locking indexes</a></li>
<li><a href="https://www.postgresql.org/docs/current/routine-reindex.html">Routine reindexing</a></li>
<li><a href="https://www.postgresql.org/docs/9.3/indexes-examine.html">Examining index usage</a></li>
<li><a href="https://www.postgresql.org/docs/9.3/monitoring-stats.html">Monitoring stats</a></li>
</ul>


  </div>

<div>
    <p><small> This is a post 📖 in the</small>
         <strong> <a href='/series/tuning-postgres-using-indexes'> Tuning Postgres using Indexes</a> </strong>
    <small>series. </small>  </p>
    <ul class="post-content h3">
        
            
                <li class="post-description">
                    Part 1: This Article - Postgres Performance Tuning Manual: Indexes 
                </li>
            
        
            
                <li class="post-description">
                    <a href="http://kishansharma.in/posts/postgres-performance-tuning-manualquery-plans/">
                        Part 2: Postgres Performance Tuning Manual: Query Plans
                    </a>
                </li>
            
        
    </ul>
</div>


  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://kishansharma.in/tags/postgres/">postgres</a></li>
      <li><a href="http://kishansharma.in/tags/index/">index</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://kishansharma.in/posts/kubernetes-prometheus-monitoring/">
    <span class="title">« Prev</span>
    <br>
    <span>Kubernetes Prometheus Monitoring</span>
  </a>
  <a class="next" href="http://kishansharma.in/posts/postgres-performance-tuning-manualquery-plans/">
    <span class="title">Next »</span>
    <br>
    <span>Postgres Performance Tuning Manual: Query Plans</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Indexes on twitter"
        href="https://twitter.com/intent/tweet/?text=Postgres%20Performance%20Tuning%20Manual%3a%20Indexes&amp;url=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualindexes%2f&amp;hashtags=postgres%2cindex">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Indexes on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualindexes%2f&amp;title=Postgres%20Performance%20Tuning%20Manual%3a%20Indexes&amp;summary=Postgres%20Performance%20Tuning%20Manual%3a%20Indexes&amp;source=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualindexes%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Indexes on reddit"
        href="https://reddit.com/submit?url=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualindexes%2f&title=Postgres%20Performance%20Tuning%20Manual%3a%20Indexes">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Indexes on facebook"
        href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualindexes%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Indexes on whatsapp"
        href="https://api.whatsapp.com/send?text=Postgres%20Performance%20Tuning%20Manual%3a%20Indexes%20-%20http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualindexes%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Postgres Performance Tuning Manual: Indexes on telegram"
        href="https://telegram.me/share/url?text=Postgres%20Performance%20Tuning%20Manual%3a%20Indexes&amp;url=http%3a%2f%2fkishansharma.in%2fposts%2fpostgres-performance-tuning-manualindexes%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer><script src="https://giscus.app/client.js"
        data-repo="kshnsink/kshnsink.github.io"
        data-repo-id="R_kgDOJLcmGA"
        data-category="General"
        data-category-id="DIC_kwDOJLcmGM4CWF88"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="dark_high_contrast"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="http://kishansharma.in/">Kishan&#39;s World</a></span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
